$.(
    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'TRANSFORM FOR SABA RELEASE 45 - But with LOCAL thumbnbail';
    $comment := 'Author: Martin Holden';
    $comment := 'Date: 19-SEP-2019';
    $comment := '*******************************************************';
    $comment := '*******************************************************';

    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'Start of Generic Function Library';

    $comment := '*******************************************************';
    $comment := '* Converts a string such as description to plain string,by stripping out';
    $comment := '* HTML tags and HTML Entities';
    $comment := '* @param {string} $source';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';
    $plainstring := function ($source) {(
        $htmltags := /<\/?([a-z0-9]*)\b[^>]*>?/;
        $dash := /[\u2010\u2013\u2014\u2015]|&(#8210;|#8211;|#8212;|#8213;|hyphen|dash|ndash;|mdash;|horbar;)/;
        $apos := /&(#8217;|apos;|rsquo;)|[\u2019|\u8217]/;
        $copy := /[\u00A9]|&(#169;|copy;)/;
        $tm := /[\u2122]|&(#8482;|trade;)/;
        $registered := /[\u00AE]|&(#174;|reg;)/;
        $curylydoublequotes := /[\u201C\u201D\u201E\u201F\u2033\u2036]|&(ldquo;|rdquo;)/;
        $pipe := /[\u007c]|&(verbar;|vert;|VerticalLine;)/;
        $nbsp := /[\u00A0]|&(#160;|#xA0;|nbsp;)/;
        $otherentities := /&(#?[\w\d]+;)/;

        $result := $source ? $trim($source) : '';
        $result := $replace($result, $pipe, '-');
        $result := $replace($result, $htmltags, '');
        $result := $replace($result, $dash, '-');
        $result := $replace($result, $copy, '(c)');
        $result := $replace($result, $registered, '(r)');
        $result := $replace($result, $tm, '(tm)');
        $result := $replace($result, $apos, '\u0027');
        $result := $replace($result, $curylydoublequotes, '\u0022');
        $result := $replace($result, $nbsp, ' ');
        $result := $replace($result, $otherentities, '');
        $result; 
    )};

    $comment := '*******************************************************';
    $comment := '* Shortens a string at a word boundary to the specified length, option to';
    $comment := '* define suffix to show this such as ...';
    $comment := '* @param {string} $source';
    $comment := '* @param {number} $maxlength - The maximum length, if $ellipsisString is';
    $comment := '*                                 the overall length allows for this';
    $comment := '* @param {string} $ellipsisString - The suffix to use';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';
    $ellipsis := function ($source, $maxlength, $ellipsisString) {(
        $wordboundary := /\s(\w+)$/;
        $trimlength := $maxlength - $length($ellipsisString);

        $needtrim := ($length($source) > $maxlength);
        $trimmedSource := $needtrim ? $trim($substring($source, 0, $trimlength));

        $trimmedSource := $replace($trimmedSource, $wordboundary, '') & $ellipsisString;
        $needtrim ? $trimmedSource : $source;
    )};

    $comment := '*******************************************************';
    $comment := '* Converts and ISO8601 format duration string such as PT1H34M56S';
    $comment := '* to a numeric value of total seconds';
    $comment := '* @param {string} $isoduration - ISO8601 format duration';
    $comment := '* @returns {number}';
    $comment := '*******************************************************';    
    $isodurationtoseconds := function ($isoduration) {(
        $input := $isoduration = null ? '' : $isoduration;
        $time := $substringAfter($input, 'T');
        $hours := $contains($time, 'H') ? $substringBefore($time, 'H') : '0';
        $remainder := $substringAfter($time, 'H');
        $minutes := $contains($remainder, 'M') ? $substringBefore($remainder, 'M') : '0';
        $remainder := $substringAfter($remainder, 'M');
        $seconds := $contains($remainder, 'S') ? $substringBefore($remainder, 'S') : '0';
        $result := (($number($hours) * 3600) + ($number($minutes) * 60) + $number($seconds));
        $result;
    )};

    $comment := '*******************************************************';
    $comment := '* Converts and ISO8601 format duration string such as PT1H34M56S';
    $comment := '* to a numeric value of total minutes, to the specified precision';
    $comment := '* @param {string} $isoduration - ISO8601 format duration';
    $comment := '* @param {number} [$precision=2] - The precision';
    $comment := '* @returns {number}';
    $comment := '*******************************************************';  
    $isodurationtominutes := function ($isoduration, $precision) {(
        $seconds := $isodurationtoseconds($isoduration);
        $prec := $exists($precision) ? $precision : 2;
        $result := $seconds = 0 ? 0 : $round($seconds / 60, $prec);
        $result;
    )};

    $comment := '*******************************************************';
    $comment := '* Converts and ISO8601 format duration string such as PT1H34M56S';
    $comment := '* to a numeric value of total hours, to the specified precision';
    $comment := '* @param {string} $isoduration - ISO8601 format duration';
    $comment := '* @param {number} [$precision=2] - The precision';
    $comment := '* @returns {number}';
    $comment := '*******************************************************';  
    $isodurationtohours := function ($isoduration, $precision) {(
        $seconds := $isodurationtoseconds($isoduration);
        $prec := $exists($precision) ? $precision : 2;
        $result := $seconds = 0 ? 0 : $round($seconds / 3600, $prec);
        $result;
    )};


    $comment := '*******************************************************';
    $comment := '* Converts and ISO8601 format duration string such as PT1H34M56S';
    $comment := '* to a string in format hh:mm. No rounding so example would be 01:34';
    $comment := '* @param {string} $isoduration - ISO8601 format duration';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';  
    $isodurationtohhmm := function ($isoduration) {(
        $input := $isoduration = null ? 'PT0H0M0S' : $isoduration;
        $time := $substringAfter($input, 'T');
        $hours := $contains($time, 'H') ? $substringBefore($time, 'H') : '00';
        $remainder := $contains($time, 'H') ? $substringAfter($time, 'H') : $time;
        $minutes := $contains($remainder, 'M') ? $substringBefore($remainder, 'M') : '00';
        $remainder := $substringAfter($remainder, 'M'); $seconds := $contains($remainder, 'S') ? $substringBefore($remainder, 'S') : '00';
        $result := $pad($hours, -2, '0') & ':' & $pad($minutes, -2, '0');
        $result;
    )};

    $comment := '*******************************************************';
    $comment := '* Converts and ISO8601 format duration string such as PT1H34M56S';
    $comment := '* to a string in format hh:mm:ss. So example would be 01:34:56';
    $comment := '* @param {string} $isoduration - ISO8601 format duration';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';  
    $isodurationtohhmmss := function ($isoduration) {(
        $input := $isoduration = null ? 'PT0H0M0S' : $isoduration;
        $time := $substringAfter($input, 'T');
        $hours := $contains($time, 'H') ? $substringBefore($time, 'H') : '00';
        $remainder := $contains($time, 'H') ? $substringAfter($time, 'H') : $time;
        $minutes := $contains($remainder, 'M') ? $substringBefore($remainder, 'M') : '00';
        $remainder := $substringAfter($remainder, 'M'); $seconds := $contains($remainder, 'S') ? $substringBefore($remainder, 'S') : '00';
        $result := $pad($hours, -2, '0') & ':' & $pad($minutes, -2, '0') & ':' & $pad($seconds, -2, '0');
        $result;
    )};


    $comment := '*******************************************************';
    $comment := '* Take an array of objects, and return a JSON object where:';
    $comment := '*      JSON Key is $prefix with incrementing value e.g. KEY1, KEY2';
    $comment := '*      JSON Value is the value e.g. en-us, or if array of objects a';
    $comment := '*        $delimiter delimited string. e.g. en-us|Title1|Description1';
    $comment := '* @param {string} $source - The array';
    $comment := '* @param {string} $prefix - The prefix to use as the JSON Key';
    $comment := '* @param {number} [$maxCount=10] - The number of Keys';
    $comment := '* @param {string} [$delimiter=|] - The delimiter for Object strings';
    $comment := '* @returns {Object}';
    $comment := '*******************************************************';  
    $flattenArrayAndObject := function($source, $prefix, $maxCount, $delimiter) {(
        $maxCount := $maxCount ? $maxCount : 10;
        $delimiter := $delimiter ? $delimiter : '|';

        $padarray := [1..$maxCount].('');
        $sourceArray := $count($source)=0 ? [] : [];
        $result := '';
        
        $sourceArray := $append($sourceArray, $map($source, function ($v, $i, $a) {(
            $model := $count($keys($v)) > 0 ? $v : { 'key': $v ? $v : '' };
            $needdelimiter:= $count($keys($v)) > 0 ? $delimiter : '';
            $trimend:= $count($keys($v)) > 0;
            $kv := $spread($model);
            $result:= $reduce($kv, function($accum, $val) {(
                $accum & $each($val, function($val, $key) {$val}) & $needdelimiter;
            )}, '');
                $trimend ? $substring($result,0,$length($result)-1) : $result;
        )})
        );

        $sourceArray := $filter($sourceArray, function ($v, $i, $a) {
            $v != ''
        });

        $sourceArray := $append($sourceArray, $padarray);
    
        $sourceArray := $filter($sourceArray, function ($v, $i, $a) {
            $i < $maxCount
        });

        $sourceArrayDelimited := $map($sourceArray, function ($v, $i, $a) {
            $prefix & ($i + 1) & '~|~' & $v
        });

        $sourceArrayDelimited.{
            $substringBefore('~|~'): $substringAfter('~|~')
        }
    )};

    $comment := '*******************************************************';
    $comment := '* Get the language string from a RFC5646 locale';
    $comment := '* @param {string} $locale - RFC 5646 language tag, consisting of';
    $comment := '*                    2-character language code and optional variant/region';
    $comment := '*                    code, with hyphen delimiter (e.g. en, en-US';
    $comment := '* @param {boolean} [$languageonly=false] - Only check with language code';
    $comment := '* @param {string} [$default=] - Default when no match.';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';  
    $rfc5646language := function ($locale, $languageonly, $default) {(
            $defaultLanguage := $default ? $default : '';
            $checkLanguageOnly := $languageonly ? $languageonly : false;

            $RFC5646_LANGUAGE_TAGS := [{
                'af': 'Afrikaans',
                'af-ZA': 'Afrikaans (South Africa)',
                'ar': 'Arabic',
                'ar-AE': 'Arabic (U.A.E.)',
                'ar-BH': 'Arabic (Bahrain)',
                'ar-DZ': 'Arabic (Algeria)',
                'ar-EG': 'Arabic (Egypt)',
                'ar-IQ': 'Arabic (Iraq)',
                'ar-JO': 'Arabic (Jordan)',
                'ar-KW': 'Arabic (Kuwait)',
                'ar-LB': 'Arabic (Lebanon)',
                'ar-LY': 'Arabic (Libya)',
                'ar-MA': 'Arabic (Morocco)',
                'ar-OM': 'Arabic (Oman)',
                'ar-QA': 'Arabic (Qatar)',
                'ar-SA': 'Arabic (Saudi Arabia)',
                'ar-SY': 'Arabic (Syria)',
                'ar-TN': 'Arabic (Tunisia)',
                'ar-YE': 'Arabic (Yemen)',
                'az': 'Azeri (Latin)',
                'az-AZ': 'Azeri (Latin) (Azerbaijan)',
                'az-Cyrl-AZ': 'Azeri (Cyrillic) (Azerbaijan)',
                'be': 'Belarusian',
                'be-BY': 'Belarusian (Belarus)',
                'bg': 'Bulgarian',
                'bg-BG': 'Bulgarian (Bulgaria)',
                'bs-BA': 'Bosnian (Bosnia and Herzegovina)',
                'ca': 'Catalan',
                'ca-ES': 'Catalan (Spain)',
                'cs': 'Czech',
                'cs-CZ': 'Czech (Czech Republic)',
                'cy': 'Welsh',
                'cy-GB': 'Welsh (United Kingdom)',
                'da': 'Danish',
                'da-DK': 'Danish (Denmark)',
                'de': 'German',
                'de-AT': 'German (Austria)',
                'de-CH': 'German (Switzerland)',
                'de-DE': 'German (Germany)',
                'de-LI': 'German (Liechtenstein)',
                'de-LU': 'German (Luxembourg)',
                'dv': 'Divehi',
                'dv-MV': 'Divehi (Maldives)',
                'el': 'Greek',
                'el-GR': 'Greek (Greece)',
                'en': 'English',
                'en-AU': 'English (Australia)',
                'en-BZ': 'English (Belize)',
                'en-CA': 'English (Canada)',
                'en-CB': 'English (Caribbean)',
                'en-GB': 'English (United Kingdom)',
                'en-IE': 'English (Ireland)',
                'en-JM': 'English (Jamaica)',
                'en-NZ': 'English (New Zealand)',
                'en-PH': 'English (Republic of the Philippines)',
                'en-TT': 'English (Trinidad and Tobago)',
                'en-US': 'English (United States)',
                'en-ZA': 'English (South Africa)',
                'en-ZW': 'English (Zimbabwe)',
                'eo': 'Esperanto',
                'es': 'Spanish',
                'es-AR': 'Spanish (Argentina)',
                'es-BO': 'Spanish (Bolivia)',
                'es-CL': 'Spanish (Chile)',
                'es-CO': 'Spanish (Colombia)',
                'es-CR': 'Spanish (Costa Rica)',
                'es-DO': 'Spanish (Dominican Republic)',
                'es-EC': 'Spanish (Ecuador)',
                'es-ES': 'Spanish (Spain)',
                'es-GT': 'Spanish (Guatemala)',
                'es-HN': 'Spanish (Honduras)',
                'es-MX': 'Spanish (Mexico)',
                'es-NI': 'Spanish (Nicaragua)',
                'es-PA': 'Spanish (Panama)',
                'es-PE': 'Spanish (Peru)',
                'es-PR': 'Spanish (Puerto Rico)',
                'es-PY': 'Spanish (Paraguay)',
                'es-SV': 'Spanish (El Salvador)',
                'es-UY': 'Spanish (Uruguay)',
                'es-VE': 'Spanish (Venezuela)',
                'et': 'Estonian',
                'et-EE': 'Estonian (Estonia)',
                'eu': 'Basque',
                'eu-ES': 'Basque (Spain)',
                'fa': 'Farsi',
                'fa-IR': 'Farsi (Iran)',
                'fi': 'Finnish',
                'fi-FI': 'Finnish (Finland)',
                'fo': 'Faroese',
                'fo-FO': 'Faroese (Faroe Islands)',
                'fr': 'French',
                'fr-BE': 'French (Belgium)',
                'fr-CA': 'French (Canada)',
                'fr-CH': 'French (Switzerland)',
                'fr-FR': 'French (France)',
                'fr-LU': 'French (Luxembourg)',
                'fr-MC': 'French (Principality of Monaco)',
                'gl': 'Galician',
                'gl-ES': 'Galician (Spain)',
                'gu': 'Gujarati',
                'gu-IN': 'Gujarati (India)',
                'he': 'Hebrew',
                'he-IL': 'Hebrew (Israel)',
                'hi': 'Hindi',
                'hi-IN': 'Hindi (India)',
                'hr': 'Croatian',
                'hr-BA': 'Croatian (Bosnia and Herzegovina)',
                'hr-HR': 'Croatian (Croatia)',
                'hu': 'Hungarian',
                'hu-HU': 'Hungarian (Hungary)',
                'hy': 'Armenian',
                'hy-AM': 'Armenian (Armenia)',
                'id': 'Indonesian',
                'id-ID': 'Indonesian (Indonesia)',
                'is': 'Icelandic',
                'is-IS': 'Icelandic (Iceland)',
                'it': 'Italian',
                'it-CH': 'Italian (Switzerland)',
                'it-IT': 'Italian (Italy)',
                'ja': 'Japanese',
                'ja-JP': 'Japanese (Japan)',
                'ka': 'Georgian',
                'ka-GE': 'Georgian (Georgia)',
                'kk': 'Kazakh',
                'kk-KZ': 'Kazakh (Kazakhstan)',
                'kn': 'Kannada',
                'kn-IN': 'Kannada (India)',
                'ko': 'Korean',
                'ko-KR': 'Korean (Korea)',
                'kok': 'Konkani',
                'kok-IN': 'Konkani (India)',
                'ky': 'Kyrgyz',
                'ky-KG': 'Kyrgyz (Kyrgyzstan)',
                'lt': 'Lithuanian',
                'lt-LT': 'Lithuanian (Lithuania)',
                'lv': 'Latvian',
                'lv-LV': 'Latvian (Latvia)',
                'mi': 'Maori',
                'mi-NZ': 'Maori (New Zealand)',
                'mk': 'FYRO Macedonian',
                'mk-MK': 'FYRO Macedonian (Former Yugoslav Republic of Macedonia)',
                'mn': 'Mongolian',
                'mn-MN': 'Mongolian (Mongolia)',
                'mr': 'Marathi',
                'mr-IN': 'Marathi (India)',
                'ms': 'Malay',
                'ms-BN': 'Malay (Brunei Darussalam)',
                'ms-MY': 'Malay (Malaysia)',
                'mt': 'Maltese',
                'mt-MT': 'Maltese (Malta)',
                'nb': 'Norwegian (Bokm?l)',
                'nb-NO': 'Norwegian (Bokm?l) (Norway)',
                'nl': 'Dutch',
                'nl-BE': 'Dutch (Belgium)',
                'nl-NL': 'Dutch (Netherlands)',
                'nn-NO': 'Norwegian (Nynorsk) (Norway)',
                'ns': 'Northern Sotho',
                'ns-ZA': 'Northern Sotho (South Africa)',
                'pa': 'Punjabi',
                'pa-IN': 'Punjabi (India)',
                'pl': 'Polish',
                'pl-PL': 'Polish (Poland)',
                'ps': 'Pashto',
                'ps-AR': 'Pashto (Afghanistan)',
                'pt': 'Portuguese',
                'pt-BR': 'Portuguese (Brazil)',
                'pt-PT': 'Portuguese (Portugal)',
                'qu': 'Quechua',
                'qu-BO': 'Quechua (Bolivia)',
                'qu-EC': 'Quechua (Ecuador)',
                'qu-PE': 'Quechua (Peru)',
                'ro': 'Romanian',
                'ro-RO': 'Romanian (Romania)',
                'ru': 'Russian',
                'ru-RU': 'Russian (Russia)',
                'sa': 'Sanskrit',
                'sa-IN': 'Sanskrit (India)',
                'se': 'Sami',
                'se-FI': 'Sami (Finland)',
                'se-NO': 'Sami (Norway)',
                'se-SE': 'Sami (Sweden)',
                'sk': 'Slovak',
                'sk-SK': 'Slovak (Slovakia)',
                'sl': 'Slovenian',
                'sl-SI': 'Slovenian (Slovenia)',
                'sq': 'Albanian',
                'sq-AL': 'Albanian (Albania)',
                'sr-BA': 'Serbian (Latin) (Bosnia and Herzegovina)',
                'sr-Cyrl-BA': 'Serbian (Cyrillic) (Bosnia and Herzegovina)',
                'sr-SP': 'Serbian (Latin) (Serbia and Montenegro)',
                'sr-Cyrl-SP': 'Serbian (Cyrillic) (Serbia and Montenegro)',
                'sv': 'Swedish',
                'sv-FI': 'Swedish (Finland)',
                'sv-SE': 'Swedish (Sweden)',
                'sw': 'Swahili',
                'sw-KE': 'Swahili (Kenya)',
                'syr': 'Syriac',
                'syr-SY': 'Syriac (Syria)',
                'ta': 'Tamil',
                'ta-IN': 'Tamil (India)',
                'te': 'Telugu',
                'te-IN': 'Telugu (India)',
                'th': 'Thai',
                'th-TH': 'Thai (Thailand)',
                'tl': 'Tagalog',
                'tl-PH': 'Tagalog (Philippines)',
                'tn': 'Tswana',
                'tn-ZA': 'Tswana (South Africa)',
                'tr': 'Turkish',
                'tr-TR': 'Turkish (Turkey)',
                'tt': 'Tatar',
                'tt-RU': 'Tatar (Russia)',
                'ts': 'Tsonga',
                'uk': 'Ukrainian',
                'uk-UA': 'Ukrainian (Ukraine)',
                'ur': 'Urdu',
                'ur-PK': 'Urdu (Islamic Republic of Pakistan)',
                'uz': 'Uzbek (Latin)',
                'uz-UZ': 'Uzbek (Latin) (Uzbekistan)',
                'uz-Cyrl-UZ': 'Uzbek (Cyrillic) (Uzbekistan)',
                'vi': 'Vietnamese',
                'vi-VN': 'Vietnamese (Viet Nam)',
                'xh': 'Xhosa',
                'xh-ZA': 'Xhosa (South Africa)',
                'zh': 'Chinese',
                'zh-CN': 'Chinese (S)',
                'zh-HK': 'Chinese (Hong Kong)',
                'zh-MO': 'Chinese (Macau)',
                'zh-SG': 'Chinese (Singapore)',
                'zh-TW': 'Chinese (T)',
                'zu': 'Zulu',
                'zu-ZA': 'Zulu (South Africa)'
            }];

            $result:= $checkLanguageOnly = true ? null : $lookup($RFC5646_LANGUAGE_TAGS, $trim($locale));
            
            $result:= $result ? $result : $lookup($RFC5646_LANGUAGE_TAGS, $trim($split($locale,'-')[0]));

            $result ? $result : $defaultLanguage;
    )};

    $comment := '*******************************************************';
    $comment := '* Remove any query string or hash parameters from a URL';
    $comment := '* @param {string} $url - The URL string';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';  
	$stripQueryStringandHash := function($url){(
    	$myurl := $url ? $url : '';
    	$split( $myurl , /\#|\?/)[0];
    )};
    
    $comment := '*******************************************************';
    $comment := '* Get the document extension from a URL';
    $comment := '* @param {string} $url - The URL string';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';  
    $getDocumentExtension := function($url){(
    	$myurl := $url ? $url : '';
        $mydocument := $reverse($split($myurl,'/'))[0];
        $contains($mydocument, '.') ? $reverse($split($mydocument, '.'))[0] : ''
    )};


    $comment := 'End of Generic Function Library';
    $comment := '*******************************************************';
    $comment := '*******************************************************';

    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'Start of Metadata Specific Functions';
    $comment := 'These are the functions common for metadata transforms';
    $comment := 'Source JSON object to be processed is one returned by:';
    $comment := ' - Scheduled Task - CONTENT_EXPORT';
    $comment := ' - API Call - content-discovery/v1/organizations/{orgId}/catalog-content';

    $comment := '*******************************************************';
    $comment := '* The plain text version of the localizedMetadata[0].title';
    $comment := '* Prefixed with contentType.displayLabel in () and ';
    $comment := '* including the technologies[0].title and';
    $comment := '* technologies[0].version';
    $comment := '* Shortened to $length with ellipsis string of ...';
    $comment := '* @param {boolean} [$includecontenttype=true] - Include';
    $comment := '*                  the contentype :';        
    $comment := '* @param {boolean} [$includetechnology=true] - Include';
    $comment := '*                  the technology and version in title';
    $comment := '*                  if title does not contain :';
    $comment := '* @param {number} [$length=255] - Maximum length';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';  
    $metadatatitle := function($includecontenttype, $includetechnology,$length){(
        $maxlength := $exists($length) ? $length : 255;
        $addtechnology := $exists($includetechnology) ? $boolean($includetechnology) : true;
        $addtechnology := $addtechnology ? ($contains(localizedMetadata[0].title, ':') ? false : true) : $addtechnology;

        $addcontenttype := $exists($includecontenttype) ? $boolean($includecontenttype) : true;

        $contenttypestring := $addcontenttype ? '(' & contentType.displayLabel & ') ' : '';

        $technologystring := $addtechnology ? (technologies[0].title ? $plainstring(technologies[0].title) & (technologies[0].version? ' ' & $plainstring(technologies[0].version))& ': ');

        $fulltitle := $contenttypestring & $technologystring & $plainstring(localizedMetadata[0].title);

        $ellipsis($fulltitle, $maxlength, ' ...');
    )};

    $comment := '*******************************************************';
    $comment := '* Plain text version of the localizedMetadata[0].description.';
    $comment := '*  Shortened to $length with ellipsis string of ...';
    $comment := '* @param {number} [$length=2000] - Maximum length';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';
    $metadatadescription := function($length){(
        $maxlength:= $length ? $length : 2000;
        $ellipsis($plainstring(localizedMetadata[0].description), $maxlength, ' ...');
    )};


    $comment := '*******************************************************';
    $comment := '* Plain text version of the localizedMetadata[0].title.';
    $comment := '* and if defined add, delimited by $eol:';
    $comment := '*     Comma Delimited list of Authors from by';
    $comment := '*     Copyright Publisher and date from publication.publisher';
    $comment := '*     and publication.copyrightYear';
    $comment := '*     ISBN from publication.isbn';
    $comment := '* Shortened to $length with ellipsis string of ...';
    $comment := '* @param {number} [$length=2000] - Maximum length';
    $comment := '* @param {string} [$eol=\r\n] - The EOL characters to use';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';
    $metadataextendeddescription := function($length, $eol){(
        $maxlength:= $length ? $length : 2000;
        $myeol:= $eol ? $eol : '\r\n';
        $by:= $count(by) = 0 ? '' : 'By: ' & $join(by, ', ') & $myeol;
        
        $publisher := publication ? publication.publisher ? $join(['Copyright:', publication.publisher],' ') : '' : '';
        $year := publication ? publication.copyrightYear ? $join(['(c)', $string(publication.copyrightYear)],' ') : '' : '';
        $copyright := publication ? $join([$publisher, $year],' ') & $myeol : '';
        $isbn := publication ? publication.isbn ? $join(['ISBN:', publication.isbn],' ') & $myeol : '' : '';

        $publication := publication ? $join([$copyright,$isbn]) : '';

        $ellipsis($join([$by,$publication,$plainstring(localizedMetadata[0].description)]), $maxlength, ' ...');
    )};


    $comment := '*******************************************************';
    $comment := '* Enhanced sharelink combining the link and any query';
    $comment := '* string parameters based on contentType.percipioType';
    $comment := '* in lowercase lookup against $lookupValues';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';
    $metadatasharelink := function($lookupValues){(
        $urlparameter := $exists( $lookupValues) ? $lookup( $lookupValues, $lowercase(contentType.percipioType)) : '';
        link & $urlparameter;
    )};


    $comment := 'End of Metadata Specific Functions';
    $comment := '*******************************************************';
    $comment := '*******************************************************';



    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'Start of Common Metadata Specific Variables';
    $comment := 'These are the values that can change the metadata specific';
    $comment := 'functions';

    $comment := '* Whether to use the extended description option';
    $comment := '* This combines the descripion and publication data';
    $comment := '* See the $metadataextendeddescription function above';
    $commonUseExtendedDescription := $exists($override.common.UseExtendedDescription) ? $override.common.UseExtendedDescription : true;

    $comment := '* The EOL characters to use for the Extended Description';
    $comment := '* See the $metadataextendeddescription function above';
    $commonExtendedDescriptionEOL := $exists($override.common.ExtendedDescriptionEOL) ? $override.common.ExtendedDescriptionEOL : '\r\n';

    $comment := '* Whether to include contentType.displayLabel as prefix to title';
    $comment := '* See the $metadatatitle function above';
    $commonIncludeContentTypeInTitle := $exists($override.common.IncludeContentTypeInTitle) ? $override.common.IncludeContentTypeInTitle : true;

    $comment := '* Whether to include technologies[0].title and version as prefix to title';
    $comment := '* See the $metadatatitle function above';
    $commonIncludeTechnologyDetailsInTitle := $exists($override.common.IncludeTechnologyDetailsInTitle) ? $override.common.IncludeTechnologyDetailsInTitle : true;

    $comment := '* The MAPPING between Percipio contentType.percipioType lowercase';
    $comment := '* and any additions to the link';
    $comment := '* Returned value (right side) is the string to append to the link';
    $comment := '* so for example to make a link chromeless include ?chromeless';
    $commonShareLinkParametersLookup := $exists($override.common.ShareLinkParametersLookup ) ? $override.common.ShareLinkParametersLookup : {
        'audiobook': '',
        'book': '',
        'channel': '',
        'course': '',
        'linked_content': '',
        'video': ''
    };

    $comment := '* The MAPPING between Percipio contentType.percipioType lowercase';
    $comment := '* and any additions to the link for MOBILE';
    $comment := '* Returned value (right side) is the string to append to the link';
    $comment := '* so for example to make a link chromeless include ?chromeless';
    $commonMobileShareLinkParametersLookup := $exists($override.common.MobileShareLinkParametersLookup ) ? $override.common.MobileShareLinkParametersLookup : {
        'audiobook': '?chromeless',
        'book': '?chromeless',
        'channel': '?chromeless',
        'course': '?chromeless',
        'linked_content': '?chromeless',
        'video': '?chromeless'
    };

    $comment := 'End of Common Metadata Specific Variables';
    $comment := '*******************************************************';
    $comment := '*******************************************************';

    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'Start of Saba Release 45/Customer Specific Functions';

    $comment := '*******************************************************';
    $comment := '* Create a string[] that is deduplicated of values that combines these';
    $comment := '* data values:';
    $comment := '*   localizedMetadata[0].title if contentType.percipioType is channel';
    $comment := '*   keywords';
    $comment := '*   associations.areas';
    $comment := '*   associations.subjects';
    $comment := '*   associations.channels[*].title';
    $comment := '*   $otherKeyword variable';
    $comment := '* @param {string} [$otherKeyword=] - Additional Keyword to include';
    $comment := '* @returns {string[]}';
    $comment := '*******************************************************';
    $sabakeywordsarray := function($otherKeyword){(
        $keywords :=  $lowercase(contentType.percipioType) = 'channel' ? [localizedMetadata[0].title] : [];

        $keywords := keywords ? $append($keywords,keywords) : $keywords;

        $keywords := $append($keywords, $map(associations.areas, function($v, $i, $a) {
            $v ? $trim($v) : ''
        }));
          
        $keywords := $append($keywords, $map(associations.subjects, function($v, $i, $a) {
            $v ? $trim($v) : ''
        }));

        $keywords := $append($keywords, $map(associations.channels, function($v, $i, $a) {
            $v.title ? $trim($v.title) : ''
        }));

        $keywords := $otherKeyword ? $append($keywords, [ $otherKeyword]) : $keywords;
        
        $keywords := $map($sort($keywords),function($v, $i, $a){
            $i != 0 ? (( $v = $a[$i-1] ) ? '': $v) : $v }
        );
      
        $keywords := $filter($keywords, function($v, $i, $a) {
            $v != ''
        });

        $keywords
    )};

    $comment := '*******************************************************';
    $comment := '* Create JSON object with TAGn keys for populating TAGS in Saba';
    $comment := '* the values are derived from $sabakeywordsarray() function.';
    $comment := '* The values are shortened to maximum 25 characters as per Saba spec';
    $comment := '* The shortened value if it ends with &:- or open bracket is trimmed.';
    $comment := '* @param {number} [$maxCount=10] - The max number of TAGn keys';
    $comment := '* @returns {Object}';
    $comment := '*******************************************************';
    $sabatagsobject := function($maxCount){(
        $tagmaxlength:= 25;
        $maxtags := $maxCount ? $maxCount : 10;
        $padarray := [1..$maxtags].('');

        $tags := $sabakeywordsarray();

        $tags := $map($tags, function ($v, $i, $a) {(
            $badendofline:= /(([&:-]|[\x28])$)/;
            $result := $v ? $ellipsis($v,$tagmaxlength,'') : '';
            $result := $replace($result, $badendofline, '');
            $trim($result)
        )});

        $tags := $map($sort($tags), function ($v, $i, $a) {
            $i != 0 ? (($v = $a[$i - 1]) ? '' : $v) : $v
        });

        $tags := $append($tags, $padarray);

        $tags := $filter($tags, function ($v, $i, $a) {
            $i < $maxtags
        });
        
        $tag_key_value_string_combined := $map($tags, function ($v, $i, $a) {
            'TAG' & ($i + 1) & '~|~' & $v
        });
        
        $convert_to_TAGn_values := $tag_key_value_string_combined.{$substringBefore('~|~'): $substringAfter('~|~')};
        
        $convert_to_TAGn_values
    )};

    $comment := '*******************************************************';
    $comment := '* Create JSON object with CATEGORYn keys for populating CATEGORIES';
    $comment := '* in Saba the values are derived from this data:';
    $comment := '*   localizedMetadata[0].title if contentType.percipioType is channel';
    $comment := '*   associations.channels[*].title';
    $comment := '* @param {string} [$category=Skillsoft] The base category name to use';
    $comment := '*   used as prefix to channel title';
    $comment := '* @param {number} [$maxCount=10] - The max number of CATEGORYn keys';    
    $comment := '* @returns {Object}';
    $comment := '*******************************************************';
    $sabacategoriesobject := function($category, $maxCount){(
        $basecategory:= $category ? $category: 'Skillsoft';
        $maxcategories := $maxCount ? $maxCount : 10;
        $padarray := [1..$maxcategories].('');

        $categories :=  $lowercase(contentType.percipioType) = 'channel' ? [$basecategory &'\\'&localizedMetadata[0].title] : $count(associations.channels) = 0 ? [$basecategory] : [];

        $categories := $append($categories, $map(associations.channels, function ($v, $i, $a) {
            $v.title ? $trim($basecategory &'\\'&$v.title) : ''
        }));
        
        $categories := $map($sort($categories), function ($v, $i, $a) {
            $i != 0 ? (($v = $a[$i - 1]) ? '' : $v) : $v
        });
        
        $categories := $filter($categories, function ($v, $i, $a) {
            $v != ''
        });
        $categories := $append($categories, $padarray);
        
        $categories := $filter($categories, function ($v, $i, $a) {
            $i < $maxcategories
        });

        $key_value_string_combined := $map($categories, function ($v, $i, $a) {
            'CATEGORY' & ($i + 1) & '~|~' & $plainstring($v)
        });
        
        $convert_to_values := $key_value_string_combined.{$substringBefore('~|~'): $substringAfter('~|~')};
        
        $convert_to_values
    )};

    $comment := '*******************************************************';
    $comment := '* Get local image filename';
    $comment := '* @param {string} [$id] - The item unqiue id';
    $comment := '* @param {string} [$imageurl] - The URL to the thumbnail';
    $comment := '* @returns {string}';
    $comment := '*******************************************************';
    $sabaimagefilename := function($id, $imageurl) {(
    	$myimageextension := $imageurl ? $trim($getDocumentExtension($stripQueryStringandHash($imageurl))) : '';
        $myid := $id ? $trim($id) : '';
        $mydelimiter := $myimageextension = '' ? '' : '.';
        $join([$myid,$myimageextension],$mydelimiter)
    )};

    $comment := 'End of Saba Release 45/Customer Specific Functions';
    $comment := '*******************************************************';
    $comment := '*******************************************************';



    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'Start of Saba Release 45/Customer Specific Variables';
    $comment := 'These are the values that can be changed per customer';
    $comment := 'Refer to SABA PERCIPIO IMPLEMENTATION GUIDE';


    $comment := '* The DOMAIN that must exist in Saba where the active Percipio Content';
    $comment := '* should be';
    $saba_ACTIVEDOMAIN := $exists($override.saba.activedomain) ? $override.saba.activedomain :'World';

    $comment := '* The DOMAIN that must exist in Saba where the inactive Percipio Content';
    $comment := '* should be';
    $saba_ARCHIVEDOMAIN := $exists($override.saba.archivedomain) ? $override.saba.archivedomain :'Archive';

    $comment := '* The CONTENT PROVIDER this value must exist in Saba, and must be a';
    $comment := '* URL Vendor so xAPI works';
    $saba_CONTENTPROVIDER := $exists($override.saba.contentprovider) ? $override.saba.contentprovider :'Percipio_URL_Vendor';
    
    $comment := '* The DELIVERY VENDOR this value must exist in Saba';
    $saba_DELIVERYVENDOR := $exists($override.saba.deliveryvendor) ? $override.saba.deliveryvendor :'Saba';
 
    $comment := '* The CONTENT folder where content is added that must exist in Saba content';
    $comment := '* library';
    $saba_CONTENTFOLDER := $exists($override.saba.contentfolder) ? $override.saba.contentfolder :'PERCIPIO_CONTENT';

    $comment := '* The PLAYER TEMPLATE that must exist in Saba';
    $saba_PLAYERTEMPLATE :=  $exists($override.saba.playertemplate) ? $override.saba.playertemplate :'Percipio';

    $comment := '* The CONTENT SERVER where content is added that must exist in Saba content';
    $saba_CONTENTSERVER := $exists($override.saba.contentserver) ? $override.saba.contentserver :'Saba Default Content Server';

    $comment := '* The SABA Account that must exist in Saba that owns this content';
    $saba_OWNER := $exists($override.saba.owner) ? $override.saba.owner :'SSADMIN';

    $comment := '* The MAPPING between Percipio localeCode to SABA language string';
    $comment := '* The PERCIPIO (left side) value is the lower case value before the';
    $comment := '* hyphen in the locale i.e. en-us -> en; fr-FR -> fr';
    $saba_LANGUAGEMAP := $exists($override.saba.languagemap) ? $override.saba.languagemap : {
              'en': 'English',
              'fr': 'French',
              'de': 'German',
              'es': 'Spanish'
            };

    $comment := '* The default SABA language string to use if the map does not succeed';
    $saba_DEFAULTLANGUAGE := $exists($override.saba.defaultlanguage) ? $override.saba.defaultlanguage :'English';

    $comment := '* The MAPPING between Percipio contentType.percipioType lowercase';
    $comment := '* that controls whether type can be marked COMPLETED thru receipt';
    $comment := '* of a COMPLETED xAPI statement from Percipio';
    $saba_MARKCOMPLETEEXTERNALMAP := $exists($override.saba.markcompleteexternalmap) ? $override.saba.markcompleteexternalmap : {
                'audiobook': 'TRUE',
                'book': 'TRUE',
                'channel': 'FALSE',
                'course': 'TRUE',
                'linked_content': 'TRUE',
                'video': 'TRUE'
              };

    $comment := '* The PREFIX combined with contentType.displayLabel that is used';
    $comment := '* for SABA Delivery types. The Delivery types must exist in SABA';
    $comment := '* If no prefix needed set to empty string, make sure to include';
    $comment := '* trailing space if defined';
    $saba_DELIVERYTYPEPREFIX := $exists($override.saba.deliverytypeprefix) ? $override.saba.deliverytypeprefix : 'Skillsoft ';

    $comment := '* The default SABA Author string to use if the by array is empty';
    $comment := '* in the Percipio data';
    $saba_DEFAULTAUTHOR := $exists($override.saba.defaultauthor) ? $override.saba.defaultauthor :'Skillsoft';

    $comment := '* The number of TAGSn values to include set to 0 to not return any';
    $comment := '* For more information see the $sabatagsobject function above';
    $saba_MAXTAGS := $exists($override.saba.maxtags) ? $override.saba.maxtags : 5;
    
    $comment := '* The number of CATEGORYn values to include set to 0 to not return any';
    $comment := '* For more information see the $sabacategoriesobject function above';
    $saba_MAXCATEGORIES := $exists($override.saba.maxcategories) ? $override.saba.maxcategories : 5;
    
    $comment := '* The base Category value to use in the $sabacategoriesobject function above';
    $saba_BASECATEGORY := $exists($override.saba.basecategory) ? $override.saba.basecategory : 'Skillsoft';
    
    $comment := '* The Saba mobilecompatabilty value to use in the transform';
    $comment := '* The current options based on Saba 45.0.0.202 are:';
    $comment := '* Value    UI Name';
    $comment := '* allDevices    All Devices';
    $comment := '* notCompatible    Not Compatible';
    $comment := '* iPhone    iPhone';
    $comment := '* iPad    iPad';
    $comment := '* both    iPhone and iPad';
    $comment := '* androidSmall    Android Small Size Device';
    $comment := '* androidNormal    Android Normal Size Device';
    $comment := '* androidLargeAndAbove    Android Large and Above Size Device';
    $comment := '* iPhone-responsive    iPhone-responsive';
    $comment := '* iPad-responsive    iPad-responsive';
    $comment := '* both-responsive    iPhone and iPad-responsive';
    $comment := '* allDevice-responsive    AllDevices-responsive';
    $comment := '* allLargeDevices    All Large Devices-responsive';
    $comment := '* allSmallDevices    All Small Devices-responsive';
    $saba_MOBILECOMPATABILTY := $exists($override.saba.mobilecompatabilty) ? $override.saba.mobilecompatabilty : 'allDevice-responsive';

    $comment := 'End of Saba Release 45/Customer Specific Variables';
    $comment := '*******************************************************';
    $comment := '*******************************************************';


    $comment := '*******************************************************';
    $comment := '*******************************************************';
    $comment := 'START OF TRANSFORM';

    $comment := '*******************************************************';
    $comment := 'Transform the basic data, uses the CONSTANTS specified above';

    $transformed_data := (
        $.{
        'ID': '',
        'CONTENTTITLE': localizedMetadata[0].title ? $metadatatitle($commonIncludeContentTypeInTitle, $commonIncludeTechnologyDetailsInTitle, 254) : '',
        'NEW_CONTENTTITLE': localizedMetadata[0].title ? $metadatatitle($commonIncludeContentTypeInTitle, $commonIncludeTechnologyDetailsInTitle, 254) : '',
        'NEW_COURSETITLE': localizedMetadata[0].title ? $metadatatitle($commonIncludeContentTypeInTitle, $commonIncludeTechnologyDetailsInTitle, 254) : '',
        'CONTENTFORMAT': 'URL',
        'SPLIT': lifecycle.status = 'ACTIVE' ? $saba_ACTIVEDOMAIN : $saba_ARCHIVEDOMAIN,
        'PLAYERTEMPLATE': $saba_PLAYERTEMPLATE,
        'ZIPFILENAME': '',
        'CSFILESTITLE': '',
        'CSFILESRELATIVEPATH': '',
        'CREATEWBTCOURSE': 'TRUE',
        'MOBILECOMPATIBILITY': $saba_MOBILECOMPATABILTY,
        'CONTENTFOLDER': $saba_CONTENTFOLDER,
        'CONTENTTYPE': 'Website',
        'EXTERNALID': xapiActivityId,
        'COURSE_NO': id,
        'AVAILABLEOFFLINE': '',
        'VERSION': '',
        'CONTENTPROVIDER': $saba_CONTENTPROVIDER,
        'DELIVERYVENDOR': $saba_DELIVERYVENDOR,
        'SECURECONTEXT': '',
        'CONTENTSERVER': $saba_CONTENTSERVER,
        'LOCATIONORURL': $metadatasharelink($commonShareLinkParametersLookup),
        'LAUNCHURL': $metadatasharelink($commonShareLinkParametersLookup),
        'CONTENTDESCRIPTION': localizedMetadata[0].description ? $commonUseExtendedDescription ? $metadataextendeddescription(2000,$commonExtendedDescriptionEOL) : $metadatadescription(2000) : '',
        'COURSE_ABSTRACT': localizedMetadata[0].description ? $commonUseExtendedDescription ? $metadataextendeddescription(1000,$commonExtendedDescriptionEOL) : $metadatadescription(1000) : '',
        'OWNER': $saba_OWNER,
        'SUREVALMRA': '',
        'ISSCORING': 'FALSE',
        'ESIGNATURE': '',
        'USEAICCBRIDGE': '',
        'ISSECURE': '',
        'AUTHOR': $count(by) = 0 ? $saba_DEFAULTAUTHOR : $trim($substring($join(by, ', '), 0, 255)),
        'LANGUAGE': (
                $language := $lookup($saba_LANGUAGEMAP, ($lowercase(localeCodes[0] ? $split(localeCodes[0],'-')[0] : 'en')));
                $language ? $language : $saba_DEFAULTLANGUAGE
        ),
        'KEYWORDS' :  (
            $keywordsarray := $sabakeywordsarray();
            $count($keywordsarray) = 0 ? '' : $join($keywordsarray,',')
        ),
        'CONTENT_STATUS': lifecycle.status = 'ACTIVE' ? 'PUBLISHED' : 'ON_HOLD',
        'COURSE_IMAGE': $sabaimagefilename(id, imageUrl),
        'DESCRIPTION': localizedMetadata[0].description ? $commonUseExtendedDescription ? $metadataextendeddescription(2000,$commonExtendedDescriptionEOL) : $metadatadescription(2000) : '',
        'DISPLAY_CALL_CENTER': lifecycle.status = 'ACTIVE' ? 'TRUE' : 'FALSE',
        'DISPLAY_LEARNER': lifecycle.status = 'ACTIVE' ? 'TRUE' : 'FALSE',
        'WBT_DURATION': $isodurationtohhmm(duration),
        'WBT_DESCRIPTION': localizedMetadata[0].description ? $commonUseExtendedDescription ? $metadataextendeddescription(2000,$commonExtendedDescriptionEOL) : $metadatadescription(2000) : '',
        'MARK_COMPLETE_EXTERNALLY': (
            $markComplete := $lookup($saba_MARKCOMPLETEEXTERNALMAP, $lowercase(contentType.percipioType));
            $markComplete ? $markComplete : 'FALSE';
        ),
        'DELIVERY_TYPE': $trim($saba_DELIVERYTYPEPREFIX & contentType.displayLabel),
        'DISCONTINUE_FROM' : lifecycle.status = 'ACTIVE' ? '' : $substringBefore($now(),'T'),
        'EXPIRATIONDATE' : lifecycle.status = 'ACTIVE' ? '' : $substringBefore($now(),'T'),
        'DROP_REGISTRATIONS' : lifecycle.status = 'ACTIVE' ? '' : 'TRUE',
        'DISCONTINUE_ALL_ENROLLMENTS' : lifecycle.status = 'ACTIVE' ? '' : 'TRUE',
        'REMOVE_COURSE_FROM_ALL_PLANS': lifecycle.status = 'ACTIVE' ? '' : 'TRUE',
        'COURSE_HIDE_CLASSMATES': 'FALSE',
        'COURSE_TARGET_DAYS': 0,
        'LXP_CONTENT': 'FALSE'
      }
    );

    $comment := '*******************************************************';
    $comment := 'Combine the :';
    $comment := '   $transformed_data - Basic transfomed data';
    $comment := '   $sabatagsobject - The TAGSn data derived from the function';
    $comment := '                        if $saba_MAXTAGS != 0';
    $comment := '   $sabacategoriesobject - The CATEGORYn data derived from the function';
    $comment := '                        if $saba_MAXCATEGORIES != 0';

    $tags :=  $saba_MAXTAGS = 0 ? [] : $sabatagsobject($saba_MAXTAGS);
    $categories :=  $saba_MAXCATEGORIES = 0 ? [] : $sabacategoriesobject($saba_BASECATEGORY, $saba_MAXTAGS);

    $results := $merge([$transformed_data, $tags,  $categories]);
    $results;
)